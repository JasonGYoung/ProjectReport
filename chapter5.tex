\chapter{Future Work}
Code generation using TEBNF creates several possibilities for future work.  As mentioned in subsection~\ref{subsections:ComparingCplusplusToTEBNF}, the TEBNF code generation tool can likely be optimized to produce better code.  Another possibility is to add more I/O methods to TEBNF and the TEBNF code generation tool.  There are many different ways to receive input and send output beyond what is currently supported by TEBNF and the tool.  The last improvement covered in this chapter is to add support into the TEBNF code generation tool to automatically generate graphical user interfaces at runtime.

\section{Optimizing the TEBNF Code Generation Tool}
Many different compiler optimizations could be applied to the code generated by the TEBNF code generation tool.  A likely side-effect of optimization is a reduction in the number of lines of code produced by the tool.

\indent
Some of the optimizations described by \cite{optimizations_01} could be applied to code generated by the tool.  The C++ compiler that builds the generated code will likely apply many if not all of the optimizations to the actions code.   The side-effects of poorly defined grammars is another factor to take into consideration.  For non-actions code, other optimizations described by \cite{optimizations_01} could be applied including instruction combining, expression simplification, branch elimination, and dead code elimination.

\indent
Instruction combining is the process of combining two or more instructions into one.  Expression simplification is the process of replacing expressions with more efficient ones.  Both of these optmizations could be applied to marshaling/unmarshaling code generated from grammar elements that are poorly defined by the user.

\indent
Branch elimination is an optimization that removes unnecessary branches to other branches.  A form of branch elimination could be applied to generated state machine code when states transition to other states unnecessarily.

\indent
In some cases, the code generation tool might generate empty actions function(s).
When this happens, dead code elimination could be employed to avoid generating them or calling them.

\section{New I/O Methods}
A wide range of I/O methods could be added to TEBNF.  This could include adding support for interacting with relational databases.  Support for commonly used database query languages like MySQL and PostgreSQL would allow TEBNF to interact with a wide range of systems that utilize databases.

\indent
The TCP/IP protocol is widely used and could be adapted into a set of I/O methods.  Due to the fact that TCP/IP is connection-oriented, I/O methods would be needed that support both server and client I/O.

\section{Runtime Graphical User Interface Generation}
Support for automatic GUI generation could be integrated into the TEBNF code generation tool.  Console user interfaces for generated applications would be replaced with a web-based GUI that communicates with the generated application.  The code generation process would need to employ a runtime data mining technique called software mining \cite{kennard_01,kennard_02}, which is a form of data mining that focuses on the inspection of static and runtime software information characteristics.  Some examples of static characteristics include source code files and database schemas, while runtime characteristics include polymorphic data-types, data values, and the reading and modification of an instantiated objectâ€™s current state.

\indent
Software mining \cite{kennard_01,kennard_02} would probably take place during all phases of the TEBNF code generation process.  Static characteristics could be gleaned from tokens as they are read from the input grammar and used to identify runtime characteristics in the parse tree.  These characteristics would then be used to map element and subelement objects to their appropriate GUI controls during the syntactic analysis phase.  Once this mapping is complete, the control(s) of the GUI are determined and the appropriate code can be generated.

